Index: app/google-services.json
===================================================================
diff --git a/app/google-services.json b/app/google-services.json
deleted file mode 100644
--- a/app/google-services.json	(revision 0ac127c098f84569712aff63e2007caf7fcb7071)
+++ /dev/null	(revision 0ac127c098f84569712aff63e2007caf7fcb7071)
@@ -1,48 +0,0 @@
-{
-  "project_info": {
-    "project_number": "1060146823585",
-    "firebase_url": "https://ecoproject-8684e-default-rtdb.firebaseio.com",
-    "project_id": "ecoproject-8684e",
-    "storage_bucket": "ecoproject-8684e.appspot.com"
-  },
-  "client": [
-    {
-      "client_info": {
-        "mobilesdk_app_id": "1:1060146823585:android:3e9aa81df5dd699787cbe0",
-        "android_client_info": {
-          "package_name": "com.example.ecoproject_android"
-        }
-      },
-      "oauth_client": [
-        {
-          "client_id": "1060146823585-bs3ld3qh3ddkps1vc4o4gl3smbu4lah4.apps.googleusercontent.com",
-          "client_type": 1,
-          "android_info": {
-            "package_name": "com.example.ecoproject_android",
-            "certificate_hash": "5263068b2abbb2de92eeae07b7dcc88ebf6b6df7"
-          }
-        },
-        {
-          "client_id": "1060146823585-h20slaqeg49tj96vpl9hb1kpngqu3paf.apps.googleusercontent.com",
-          "client_type": 3
-        }
-      ],
-      "api_key": [
-        {
-          "current_key": "AIzaSyAiEheAdCTHDKVgyckTQMiRVTdyiSdR8O8"
-        }
-      ],
-      "services": {
-        "appinvite_service": {
-          "other_platform_oauth_client": [
-            {
-              "client_id": "1060146823585-h20slaqeg49tj96vpl9hb1kpngqu3paf.apps.googleusercontent.com",
-              "client_type": 3
-            }
-          ]
-        }
-      }
-    }
-  ],
-  "configuration_version": "1"
-}
\ No newline at end of file
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// 파이어베이스\n\nbuildscript {\n    repositories {\n        google()\n        mavenCentral()\n    }\n    dependencies {\n        classpath 'com.google.gms:google-services:4.3.15'\n    }\n\n}\n\n\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\nplugins {\n    id 'com.android.application' version '7.4.2' apply false\n    id 'com.android.library' version '7.4.2' apply false\n    id 'org.jetbrains.kotlin.android' version '1.8.0' apply false\n}\n\n// 파이어베이스\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle b/build.gradle
--- a/build.gradle	(revision 0ac127c098f84569712aff63e2007caf7fcb7071)
+++ b/build.gradle	(date 1686270596849)
@@ -7,6 +7,8 @@
     }
     dependencies {
         classpath 'com.google.gms:google-services:4.3.15'
+        classpath 'com.kakao.sdk:v2-user:2.4.0'
+
     }
 
 }
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>plugins {\n    id 'com.android.application'\n    id 'org.jetbrains.kotlin.android'\n\n    // 파이어베이스\n    id 'com.google.gms.google-services'\n}\n\nandroid {\n    namespace 'com.example.ecoproject_android'\n    compileSdk 33\n\n    defaultConfig {\n        applicationId \"com.example.ecoproject_android\"\n        minSdk 24\n        targetSdk 33\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n    buildFeatures {\n        viewBinding true\n    }\n    sourceSets {\n        main {\n            assets {\n                srcDirs 'src\\\\main\\\\assets'\n            }\n        }\n    }\n\n}\n\ndependencies {\n\n    implementation 'androidx.core:core-ktx:1.7.0'\n    implementation 'androidx.appcompat:appcompat:1.6.1'\n    implementation 'com.google.android.material:material:1.8.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'\n    implementation 'androidx.annotation:annotation:1.3.0'\n    implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.4.1'\n    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.1'\n    implementation 'com.google.firebase:firebase-auth-ktx:22.0.0'\n    implementation 'com.google.firebase:firebase-database:20.2.2'\n    implementation 'com.google.firebase:firebase-database-ktx:20.2.2'\n    testImplementation 'junit:junit:4.13.2'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'\n\n    // 네이버 지도 SDK\n    implementation 'com.naver.maps:map-sdk:3.16.2'\n    implementation'com.google.android.gms:play-services-location:17.0.0'//현재 위치 가져오게하는 종속성\n\n    // 파이어베이스\n    implementation platform('com.google.firebase:firebase-bom:32.0.0')\n    implementation 'com.google.firebase:firebase-analytics-ktx'\n    implementation 'androidx.recyclerview:recyclerview:1.1.0'\n    implementation 'androidx.recyclerview:recyclerview-selection:1.1.0'\n    implementation 'com.github.bumptech.glide:glide:4.12.0'\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.12.0'\n    implementation 'com.google.firebase:firebase-storage-ktx:20.0.0'\n\n\n    //\n    implementation \"androidx.viewpager2:viewpager2:1.0.0\"\n    implementation 'me.relex:circleindicator:2.1.4'\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle b/app/build.gradle
--- a/app/build.gradle	(revision 0ac127c098f84569712aff63e2007caf7fcb7071)
+++ b/app/build.gradle	(date 1686270607315)
@@ -79,4 +79,9 @@
     //
     implementation "androidx.viewpager2:viewpager2:1.0.0"
     implementation 'me.relex:circleindicator:2.1.4'
+
+    implementation 'com.kakao.sdk:v2-user:2.4.0'
+
+
+
 }
\ No newline at end of file
Index: app/src/main/java/com/example/ecoproject_android/Map.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.ecoproject_android\n\nimport okhttp3.*\nimport okhttp3.Callback\nimport okhttp3.OkHttpClient\nimport android.database.Cursor\nimport android.os.Bundle\nimport android.widget.Button\nimport androidx.appcompat.app.AppCompatActivity\nimport com.naver.maps.geometry.LatLng\nimport com.naver.maps.map.*\nimport com.naver.maps.map.overlay.Marker\nimport com.naver.maps.map.overlay.PathOverlay\nimport com.naver.maps.map.util.FusedLocationSource\nimport com.naver.maps.map.widget.LocationButtonView\nimport org.json.JSONException\nimport org.json.JSONObject\nimport java.util.*\nimport java.io.IOException\n\n\nclass Map : AppCompatActivity(), OnMapReadyCallback {\n    private lateinit var mapView: MapView\n    private val LOCATION_PERMISSTION_REQUEST_CODE: Int = 1000\n    private lateinit var locationSource: FusedLocationSource\n    private lateinit var naverMap: NaverMap\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_map)\n\n        //뒤로가기\n        val back = findViewById<Button>(R.id.back)\n\n        back.setOnClickListener { finish() }\n\n        locationSource = FusedLocationSource(this, LOCATION_PERMISSTION_REQUEST_CODE)\n\n        mapView = findViewById(R.id.mapView)\n        mapView.onCreate(savedInstanceState)\n        mapView.getMapAsync(this)\n\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.onDestroy()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n\n    override fun onRequestPermissionsResult(\n        requestCode: Int,\n        permissions: Array<String>,\n        grantResults: IntArray\n    ) {\n        if (locationSource.onRequestPermissionsResult(\n                requestCode,\n                permissions,\n                grantResults\n            )\n        ) {\n            if (!locationSource.isActivated) { // 권한 거부됨\n                naverMap.locationTrackingMode = LocationTrackingMode.None\n            }\n            return\n        }\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n    }\n\n    override fun onMapReady(naverMap: NaverMap) {\n        this.naverMap = naverMap\n\n        naverMap.locationSource = locationSource\n\n        val uiSettings = naverMap.uiSettings\n        naverMap.locationTrackingMode = LocationTrackingMode.Follow\n        uiSettings.isLocationButtonEnabled = false\n        val locationButtonView = findViewById<LocationButtonView>(R.id.location)\n        locationButtonView.map = naverMap\n\n        val initialPosition = LatLng(37.506855, 127.066242)\n        val cameraUpdate = CameraUpdate.scrollTo(initialPosition)\n        naverMap.moveCamera(\n            CameraUpdate.toCameraPosition(\n                CameraPosition(\n                    NaverMap.DEFAULT_CAMERA_POSITION.target,\n                    NaverMap.DEFAULT_CAMERA_POSITION.zoom\n                )\n            )\n        )\n\n        /*여기서 부터 의류 수거함 마커*/\n        // 마커들 위치 정의\n        getVal()\n\n        // 카메라 이동되면 호출되는 이벤트\n        naverMap.addOnCameraChangeListener { reason, animated ->\n            freeActiveMarkers()\n// 정의된 마커 위치들 중\n            // 가시 거리 내에 있는 것들만 마커 생성\n            val currentPosition = getCurrentPosition(naverMap)\n            for (markerPosition in markersPosition!!) {\n                if (!withinSightMarker(currentPosition, markerPosition)) continue\n                val marker = Marker()\n                marker.isHideCollidedCaptions = true\n                marker.isHideCollidedMarkers = true\n                marker.position = markerPosition\n                marker.map = naverMap\n                activeMarkers?.add(marker)\n            }\n\n            // 현재 위치 변경 시 호출되는 메서드\n            // 가장 가까운 마커를 찾고 경로 안내를 시작하는 메서드 호출\n            findNearestMarkerAndNavigate(locationSource.lastLocation)\n        }\n    }\n\n    // 마커 정보 저장할 변수 선언\n    private var markersPosition: Vector<LatLng>? = null\n    private var activeMarkers: Vector<Marker>? = null\n\n    // 현재 카메라가 보고 있는 위치\n    private fun getCurrentPosition(naverMap: NaverMap): LatLng {\n        val cameraPosition = naverMap.cameraPosition\n        return LatLng(cameraPosition.target.latitude, cameraPosition.target.longitude)\n    }\n\n    // 선택한 마커의 위치가 가시 거리(카메라가 보고 있는 위치 반경 3km 내)에 있는지 확인\n    private val REFERANCE_LAT = 1 / 109.958489129649955\n    private val REFERANCE_LNG = 1 / 88.74\n    private val REFERANCE_LAT_X3 = 3 / 109.958489129649955\n    private val REFERANCE_LNG_X3 = 3 / 88.74\n\n    private fun withinSightMarker(currentPosition: LatLng, markerPosition: LatLng): Boolean {\n        val withinSightMarkerLat =\n            Math.abs(currentPosition.latitude - markerPosition.latitude) <= REFERANCE_LAT_X3\n        val withinSightMarkerLng =\n            Math.abs(currentPosition.longitude - markerPosition.longitude) <= REFERANCE_LNG_X3\n        return withinSightMarkerLat && withinSightMarkerLng\n    }\n\n    // 지도상에 표시되고 있는 마커들을 지도에서 삭제\n    private fun freeActiveMarkers() {\n        if (activeMarkers == null) {\n            activeMarkers = Vector()\n            return\n        }\n        for (activeMarker in activeMarkers!!) {\n            activeMarker.map = null\n        }\n        activeMarkers = Vector()\n    }\n\n    // 가장 가까운 마커를 찾고 경로 안내를 시작하는 메서드\n\n\n    // 위경도 DB 가져오기\n    private fun getVal() {\n        val dbHelper = DataBaseHelper(this)\n        val db = dbHelper.readableDatabase\n        val cursor: Cursor = db.rawQuery(\"SELECT * FROM LatLng\", null)\n        markersPosition = Vector()\n        while (cursor.moveToNext()) {\n            markersPosition!!.add(\n                LatLng(\n                    cursor.getDouble(0),\n                    cursor.getDouble(1)\n                )\n            )\n        }\n        cursor.close()\n        dbHelper.close()\n    }\n\n    // 가장 가까운 마커를 찾고 경로 안내를 시작하는 메서드\n    private fun findNearestMarkerAndNavigate(lastLocation: android.location.Location?) {\n        if (lastLocation != null && markersPosition != null && markersPosition!!.isNotEmpty()) {\n            val currentPosition = LatLng(lastLocation.latitude, lastLocation.longitude)\n            var nearestMarker: Marker? = null\n            var shortestDistance = Double.MAX_VALUE\n\n            for (marker in activeMarkers!!) {\n                val markerPosition = marker.position\n                val distance = calculateDistance(currentPosition, markerPosition)\n                if (distance < shortestDistance) {\n                    shortestDistance = distance\n                    nearestMarker = marker\n                }\n            }\n\n            // 가장 가까운 마커가 존재하면 해당 마커까지 경로 안내 시작\n            if (nearestMarker != null) {\n                navigateToMarker(nearestMarker.position)\n            }\n        }\n    }\n\n    // 두 위치간 거리 계산\n    private fun calculateDistance(position1: LatLng, position2: LatLng): Double {\n        val latDiff = Math.toRadians(position2.latitude - position1.latitude)\n        val lngDiff = Math.toRadians(position2.longitude - position1.longitude)\n        val a = Math.sin(latDiff / 2) * Math.sin(latDiff / 2) +\n                Math.cos(Math.toRadians(position1.latitude)) * Math.cos(Math.toRadians(position2.latitude)) *\n                Math.sin(lngDiff / 2) * Math.sin(lngDiff / 2)\n        val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n        val earthRadius = 6371 // 지구 반지름 (단위: km)\n        return earthRadius * c\n    }\n\n    // 선택한 마커까지 경로 안내 시작\n    private fun navigateToMarker(markerPosition: LatLng) {\n        val currentPosition = locationSource.lastLocation\n        if (currentPosition != null) {\n            val start = LatLng(currentPosition.latitude, currentPosition.longitude)\n            val end = markerPosition\n\n            // 경로 안내 생성\n            val request = createDirectionRequest(start, end)\n            sendDirectionRequest(request)\n        }\n    }\n\n    // 경로 안내를 위한 Direction API 요청 생성\n    private fun createDirectionRequest(start: LatLng, end: LatLng): Request {\n        val url = \"https://naveropenapi.apigw.ntruss.com/map-direction/v1/driving\"\n        val clientId = \"gltf29rywr\" // 본인의 네이버 클라이언트 ID 입력\n        val clientSecret = \"pp0hbjM5trHLFo0r1lazxHTDI7se0njR8o1opx9V\" // 본인의 네이버 클라이언트 시크릿 입력\n\n        val requestUrl = \"$url?start=${start.longitude},${start.latitude}&goal=${end.longitude},${end.latitude}\"\n        val request = Request.Builder()\n            .url(requestUrl)\n            .header(\"gltf29rywr\", clientId)\n            .header(\"pp0hbjM5trHLFo0r1lazxHTDI7se0njR8o1opx9V\", clientSecret)\n            .build()\n\n        return request\n    }\n\n    // 경로 안내를 위한 Direction API 요청 전송\n    private fun sendDirectionRequest(request: Request) {\n        val client = OkHttpClient()\n        client.newCall(request).enqueue(object : Callback {\n            override fun onFailure(call: Call, e: IOException) {\n                // 요청 실패 시 처리\n                e.printStackTrace()\n            }\n\n            override fun onResponse(call: Call, response: Response) {\n                // 요청 성공 시 처리\n                response.body?.let { responseBody ->\n                    val responseData = responseBody.string()\n                    try {\n                        val jsonObject = JSONObject(responseData)\n                        val route = jsonObject.getJSONArray(\"route\").getJSONObject(0)\n                        val path = route.getJSONObject(\"summary\").getString(\"path\")\n                        runOnUiThread {\n                            drawPath(path)\n                        }\n                    } catch (e: JSONException) {\n                        e.printStackTrace()\n                    }\n                }\n            }\n        })\n    }\n\n    // 경로 그리기\n    private fun drawPath(path: String) {\n        val pathCoordinates = parsePathCoordinates(path)\n\n        val pathOverlay = PathOverlay()\n        pathOverlay.coords = pathCoordinates\n        pathOverlay.map = naverMap\n    }\n\n    // 경로 좌표 파싱\n    private fun parsePathCoordinates(path: String): List<LatLng> {\n        val coordinates = path.split(\";\")\n        val pathCoordinates = mutableListOf<LatLng>()\n\n        for (coordinate in coordinates) {\n            val latLng = coordinate.split(\",\")\n            if (latLng.size == 2) {\n                val lat = latLng[1].toDouble()\n                val lng = latLng[0].toDouble()\n                pathCoordinates.add(LatLng(lat, lng))\n            }\n        }\n\n        return pathCoordinates\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/ecoproject_android/Map.kt b/app/src/main/java/com/example/ecoproject_android/Map.kt
--- a/app/src/main/java/com/example/ecoproject_android/Map.kt	(revision 0ac127c098f84569712aff63e2007caf7fcb7071)
+++ b/app/src/main/java/com/example/ecoproject_android/Map.kt	(date 1686270182259)
@@ -139,7 +139,6 @@
 
             // 현재 위치 변경 시 호출되는 메서드
             // 가장 가까운 마커를 찾고 경로 안내를 시작하는 메서드 호출
-            findNearestMarkerAndNavigate(locationSource.lastLocation)
         }
     }
 
@@ -201,121 +200,7 @@
     }
 
     // 가장 가까운 마커를 찾고 경로 안내를 시작하는 메서드
-    private fun findNearestMarkerAndNavigate(lastLocation: android.location.Location?) {
-        if (lastLocation != null && markersPosition != null && markersPosition!!.isNotEmpty()) {
-            val currentPosition = LatLng(lastLocation.latitude, lastLocation.longitude)
-            var nearestMarker: Marker? = null
-            var shortestDistance = Double.MAX_VALUE
-
-            for (marker in activeMarkers!!) {
-                val markerPosition = marker.position
-                val distance = calculateDistance(currentPosition, markerPosition)
-                if (distance < shortestDistance) {
-                    shortestDistance = distance
-                    nearestMarker = marker
-                }
-            }
-
-            // 가장 가까운 마커가 존재하면 해당 마커까지 경로 안내 시작
-            if (nearestMarker != null) {
-                navigateToMarker(nearestMarker.position)
-            }
-        }
-    }
-
-    // 두 위치간 거리 계산
-    private fun calculateDistance(position1: LatLng, position2: LatLng): Double {
-        val latDiff = Math.toRadians(position2.latitude - position1.latitude)
-        val lngDiff = Math.toRadians(position2.longitude - position1.longitude)
-        val a = Math.sin(latDiff / 2) * Math.sin(latDiff / 2) +
-                Math.cos(Math.toRadians(position1.latitude)) * Math.cos(Math.toRadians(position2.latitude)) *
-                Math.sin(lngDiff / 2) * Math.sin(lngDiff / 2)
-        val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
-        val earthRadius = 6371 // 지구 반지름 (단위: km)
-        return earthRadius * c
-    }
 
-    // 선택한 마커까지 경로 안내 시작
-    private fun navigateToMarker(markerPosition: LatLng) {
-        val currentPosition = locationSource.lastLocation
-        if (currentPosition != null) {
-            val start = LatLng(currentPosition.latitude, currentPosition.longitude)
-            val end = markerPosition
 
-            // 경로 안내 생성
-            val request = createDirectionRequest(start, end)
-            sendDirectionRequest(request)
-        }
-    }
-
-    // 경로 안내를 위한 Direction API 요청 생성
-    private fun createDirectionRequest(start: LatLng, end: LatLng): Request {
-        val url = "https://naveropenapi.apigw.ntruss.com/map-direction/v1/driving"
-        val clientId = "gltf29rywr" // 본인의 네이버 클라이언트 ID 입력
-        val clientSecret = "pp0hbjM5trHLFo0r1lazxHTDI7se0njR8o1opx9V" // 본인의 네이버 클라이언트 시크릿 입력
-
-        val requestUrl = "$url?start=${start.longitude},${start.latitude}&goal=${end.longitude},${end.latitude}"
-        val request = Request.Builder()
-            .url(requestUrl)
-            .header("gltf29rywr", clientId)
-            .header("pp0hbjM5trHLFo0r1lazxHTDI7se0njR8o1opx9V", clientSecret)
-            .build()
-
-        return request
-    }
-
-    // 경로 안내를 위한 Direction API 요청 전송
-    private fun sendDirectionRequest(request: Request) {
-        val client = OkHttpClient()
-        client.newCall(request).enqueue(object : Callback {
-            override fun onFailure(call: Call, e: IOException) {
-                // 요청 실패 시 처리
-                e.printStackTrace()
-            }
-
-            override fun onResponse(call: Call, response: Response) {
-                // 요청 성공 시 처리
-                response.body?.let { responseBody ->
-                    val responseData = responseBody.string()
-                    try {
-                        val jsonObject = JSONObject(responseData)
-                        val route = jsonObject.getJSONArray("route").getJSONObject(0)
-                        val path = route.getJSONObject("summary").getString("path")
-                        runOnUiThread {
-                            drawPath(path)
-                        }
-                    } catch (e: JSONException) {
-                        e.printStackTrace()
-                    }
-                }
-            }
-        })
-    }
-
-    // 경로 그리기
-    private fun drawPath(path: String) {
-        val pathCoordinates = parsePathCoordinates(path)
-
-        val pathOverlay = PathOverlay()
-        pathOverlay.coords = pathCoordinates
-        pathOverlay.map = naverMap
-    }
-
-    // 경로 좌표 파싱
-    private fun parsePathCoordinates(path: String): List<LatLng> {
-        val coordinates = path.split(";")
-        val pathCoordinates = mutableListOf<LatLng>()
-
-        for (coordinate in coordinates) {
-            val latLng = coordinate.split(",")
-            if (latLng.size == 2) {
-                val lat = latLng[1].toDouble()
-                val lng = latLng[0].toDouble()
-                pathCoordinates.add(LatLng(lat, lng))
-            }
-        }
-
-        return pathCoordinates
-    }
 }
 
